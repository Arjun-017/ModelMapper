using System.Collections.Immutable;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using QuickMapper.Common.Attributes;

namespace QuickMapper;

[Generator]
public class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typesToMap = context.SyntaxProvider
                       .CreateSyntaxProvider(IsModelToBeMapped, GetModelType)
                       .Where(type => type is not null)
                       .Collect();
        context.RegisterSourceOutput(typesToMap, GenerateCode);
    }

    private static bool IsModelToBeMapped(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = attribute.Name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
        
        return name == "MapTo";
    }

    private static ITypeSymbol? GetModelType(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
            return null;

        var type = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as ITypeSymbol;

        return type;
    }

    private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> typesToMap)
    {
        foreach (var type in typesToMap)
        {
            var generatedCode = new StringBuilder();
            generatedCode.AppendLine("// <auto-generated />");
            generatedCode.AppendLine();

            if (!type.ContainingNamespace.IsGlobalNamespace)
            {
                generatedCode.AppendLine($"namespace {type.ContainingNamespace.Name};");
            }

            generatedCode.AppendLine();
            generatedCode.AppendLine($"public static class {type.Name}Mapper");
            generatedCode.AppendLine("{");
            
            var attribute = type.GetAttributes().FirstOrDefault(x => x.AttributeClass.Name == nameof(MapToAttribute));
            var constructorArg = attribute.ConstructorArguments.FirstOrDefault();
            
            foreach (var item in constructorArg.Values)
            {
                var typeSymbol = item.Value as INamedTypeSymbol;
                if (typeSymbol != null)
                {
                    var destinationType = typeSymbol.ToDisplayString();
                    var destinationTypeName = destinationType.Split('.').Last();

                    generatedCode.AppendLine($"public static {destinationType} MapTo{destinationTypeName}(this {type.Name} source)");
                    generatedCode.AppendLine("{");
                    generatedCode.AppendLine($"var destination = new {destinationType}();");
                    foreach (var member in typeSymbol.GetMembers().OfType<IPropertySymbol>())
                    {
                        var propertyName = member.Name;
                        var propertyType = member.Type.ToDisplayString();

                        generatedCode.AppendLine($"destination.{propertyName} = source.{propertyName};");
                    }
                    generatedCode.AppendLine("return destination;");
                    generatedCode.AppendLine("}");
                    generatedCode.AppendLine();
                }
            }

            generatedCode.AppendLine("}");
            context.AddSource($"{type.Name}Mapper.g.cs", generatedCode.ToString());
        }
    }
}
